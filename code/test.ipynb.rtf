{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \{\
 "cells": [\
  \{\
   "cell_type": "code",\
   "execution_count": 18,\
   "metadata": \{\},\
   "outputs": [],\
   "source": [\
    "import requests\\n",\
    "import json\\n",\
    "import calendar\\n",\
    "import time\\n",\
    "import os.path as path\\n",\
    "\\n",\
    "def getMedicionesDateRange(url_api, params, fecha, a\'f1o, headers):\\n",\
    "    \\n",\
    "    # Se env\'eda petici\'f3n al servidor mediante la api con la url construida: \\n",\
    "    #    API_URL + Par\'e1metros (fechaini y fechafin) + api_key (proporcionada por AEMET con validez de 3 meses)\\n",\
    "    # Se debe hacer un bucle que solicite mediciones del periodo que deseemos con rangos no superioroes a 31 d\'edas. \\n",\
    "    # Lo ideal ser\'eda solicitar desde 01/01/2000 por meses hasta el mes en curso (A\'fan por implementar)\\n",\
    "    resp_api = requests.request(\\"GET\\", url_api, headers=headers, params=params)\\n",\
    "\\n",\
    "    # Se toman los datos devueltos en la respuesta que se trata de un objeto de tipo str con formato json\\n",\
    "    #print(type(resp_api.text))\\n",\
    "    rjson =  resp_api.text\\n",\
    "    print(rjson)\\n",\
    "\\n",\
    "    # Decodificamos el objeto json:\\n",\
    "    res = json.loads(rjson)\\n",\
    "\\n",\
    "    # Obtenenmos como resultado un dictionary python:\\n",\
    "    #print(type(res))\\n",\
    "    #print(res[\\"datos\\"])\\n",\
    "\\n",\
    "    # Tomamos la URL de descarga del set de datos generado por el servidor en respuesta a nuestra petici\'f3n\\n",\
    "    url_data = res[\\"datos\\"]\\n",\
    "\\n",\
    "    # Se env\'eda petici\'f3n al servidor para descargar los datos\\n",\
    "    resp = requests.request(\\"GET\\", url_data, headers=headers)\\n",\
    "    #print(type(resp.text))\\n",\
    "\\n",\
    "    # Se toman los datos devueltos en la respuesta que se trata de un objeto de tipo str con formato json\\n",\
    "    rjson2 =  resp.text\\n",\
    "\\n",\
    "    # Decodificamos el objeto json, obteniendo un conjunto de mediciones en formato de Diccionario Python:\\n",\
    "    mediciones = json.loads(rjson2)\\n",\
    "    #print(type(mediciones))\\n",\
    "\\n",\
    "    # A partir del diccionario obtenido, generaremos un archivo json donde guardaremos s\'f3lo los datos que necesitamos:\\n",\
    "    #   fecha: fecha de medici\'f3n ('AAAA-MM-DD')\\n",\
    "    #   nombre: nombre (ubicaci\'f3n) de la estaci\'f3n\\n",\
    "    #   provincia: Provincia de la estaci\'f3n\\n",\
    "    #   tmed: Temperatura media de ese d\'eda en grados celsius\\n",\
    "    #   prec: Precipitaci\'f3n diaria de 07 a 07 en mm (IP menos de 0.1 mm)\\n",\
    "\\n",\
    "    \\n",\
    "    # Inicializamos Diccionario vacio que contendr\'e1 los datos que deseamos guardar en formato json \\n",\
    "    datos = \{\}    \\n",\
    "    # Inicializamos lista vacia que contendr\'e1 mediciones\\n",\
    "    datos[str(fecha)] = []\\n",\
    "    # Inicializamos Diccionario vacio que utilizaremos en el paso intermedio de recuperaci\'f3n de mediciones \\n",\
    "    medicion = \{\}\\n",\
    "\\n",\
    "    # Recorremos el json que nos devolvi\'f3 el servidor y vamos construyendo nuestro propio set con los datos que deseamos\\n",\
    "    for item in mediciones:\\n",\
    "        for clave, valor in item.items():\\n",\
    "            if clave in ('fecha','nombre','provincia','tmed','prec'):\\n",\
    "                medicion[clave] = valor\\n",\
    "        datos[str(fecha)].append(medicion.copy())\\n",\
    "    #print(datos[str(fecha)])\\n",\
    "\\n",\
    "    if path.exists('mediciones_'+str(a\'f1o)+'.json'):\\n",\
    "        # Volcamos los datos del fichero en un diccionario sobre el que a\'f1adiremos los nuevos datos del a\'f1o referenciado\\n",\
    "        with open('mediciones_'+str(a\'f1o)+'.json') as file:\\n",\
    "            data = json.load(file)\\n",\
    "#             print(type(old))\\n",\
    "#             print(old)\\n",\
    "            data.update(datos)\\n",\
    "        \\n",\
    "        # Volcamos los datos generados por nosotros en un nuevo fichero que se llamar\'e1 mediciones.json\\n",\
    "        with open('mediciones_'+str(a\'f1o)+'.json', 'w+') as file:\\n",\
    "            json.dump(data, file, indent=4)\\n",\
    "    else:\\n",\
    "        # Volcamos los datos generados por nosotros en un nuevo fichero que se llamar\'e1 mediciones.json\\n",\
    "        with open('mediciones_'+str(a\'f1o)+'.json', 'w') as file:\\n",\
    "            json.dump(datos, file, indent=4)\\n",\
    "\\n",\
    "    print(\\"Done\\")"\
   ]\
  \},\
  \{\
   "cell_type": "code",\
   "execution_count": 20,\
   "metadata": \{\
    "scrolled": true\
   \},\
   "outputs": [\
    \{\
     "name": "stdout",\
     "output_type": "stream",\
     "text": [\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/8c7f5584\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/b3c5e497\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/f106a1e4\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/a40637e7\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/a97ea83c\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/31a7a025\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/8c12e257\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/a38ab692\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/d3c4bc5d\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/e44f2a59\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/95baa439\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n",\
      "\{\\n",\
      "  \\"descripcion\\" : \\"exito\\",\\n",\
      "  \\"estado\\" : 200,\\n",\
      "  \\"datos\\" : \\"https://opendata.aemet.es/opendata/sh/5dbf8d9b\\",\\n",\
      "  \\"metadatos\\" : \\"https://opendata.aemet.es/opendata/sh/b3aa9d28\\"\\n",\
      "\}\\n",\
      "Done\\n"\
     ]\
    \}\
   ],\
   "source": [\
    "main   = 'https://opendata.aemet.es/opendata/api/valores/climatologicos/diarios/datos/'\\n",\
    "param1 = 'fechaini/'\\n",\
    "param2 = 'fechafin/'\\n",\
    "slash  = '/'\\n",\
    "todas  = 'todasestaciones/'\\n",\
    "\\n",\
    "a\'f1os = list(range(2019,2020))\\n",\
    "meses = list(range(1,13))\\n",\
    "guion = '-'\\n",\
    "finfecha = 'T00:00:00UTC'\\n",\
    "finfecha2 = 'T23:59:59UTC'\\n",\
    "\\n",\
    "querystring = \{\\"api_key\\":\\"eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhcnVpenBsYUB1b2MuZWR1IiwianRpIjoiOWNjMzUyMmItZGNjYy00MzUwLTk3YWEtZjU0YWMyNTgzMmFiIiwiaXNzIjoiQUVNRVQiLCJpYXQiOjE2MDI5NjU1NTEsInVzZXJJZCI6IjljYzM1MjJiLWRjY2MtNDM1MC05N2FhLWY1NGFjMjU4MzJhYiIsInJvbGUiOiIifQ.m9Dj6SN3DCLl-uIt1lFMbJMfY2DnmrfdFc2uX_d73i8\\"\}\\n",\
    "\\n",\
    "headers = \{'cache-control': \\"no-cache\\"\}\\n",\
    "\\n",\
    "for a\'f1o in a\'f1os:\\n",\
    "    t0 = time.time()\\n",\
    "    \\n",\
    "    for mes in meses:\\n",\
    "        fecha = str(a\'f1o) + guion + str(mes)\\n",\
    "        fini = str(a\'f1o) + guion + str(mes) + guion + '1' + finfecha\\n",\
    "        ffin = str(a\'f1o) + guion + str(mes) + guion + str(calendar.monthrange(a\'f1o, mes)[1]) + finfecha2\\n",\
    "        \\n",\
    "        url_api = main + param1 + fini + slash + param2 + ffin + slash + todas\\n",\
    "        #print(url_api)\\n",\
    "        \\n",\
    "        getMedicionesDateRange(url_api, querystring, fecha, a\'f1o, headers)\\n",\
    "        \\n",\
    "        #estimaci\'f3n del tiempo de respuesta en segundos\\n",\
    "#         response_delay = time.time() - t0\\n",\
    "        #espera de 10x, con respecto al tiempo de respuesta\\n",\
    "#         time.sleep(2 * response_delay)\\n",\
    "#         print(response_delay)"\
   ]\
  \},\
  \{\
   "cell_type": "code",\
   "execution_count": 23,\
   "metadata": \{\
    "scrolled": true\
   \},\
   "outputs": [\
    \{\
     "name": "stdout",\
     "output_type": "stream",\
     "text": [\
      "\{'fecha': '2019-10-11', 'nombre': 'LLEIDA', 'provincia': 'LLEIDA', 'tmed': '19,6', 'prec': '0,0'\}\\n",\
      "Done\\n"\
     ]\
    \}\
   ],\
   "source": [\
    "import json\\n",\
    "\\n",\
    "#  Test apertura fichero generado. Pruebo filtrado por localizaci\'f3n y fecha. \\n",\
    "#  Se deber\'e1 ver como asociar una temperatura \\n",\
    "with open('mediciones_2019.json') as file:\\n",\
    "    datos = json.load(file)\\n",\
    "\\n",\
    "for medicion in datos['2019-10']:\\n",\
    "    if medicion['fecha'] == '2019-10-11' and medicion['nombre'] == 'LLEIDA':\\n",\
    "        print(medicion)\\n",\
    "\\n",\
    "print(\\"Done\\")"\
   ]\
  \},\
  \{\
   "cell_type": "code",\
   "execution_count": null,\
   "metadata": \{\},\
   "outputs": [],\
   "source": []\
  \}\
 ],\
 "metadata": \{\
  "kernelspec": \{\
   "display_name": "Python 3",\
   "language": "python",\
   "name": "python3"\
  \},\
  "language_info": \{\
   "codemirror_mode": \{\
    "name": "ipython",\
    "version": 3\
   \},\
   "file_extension": ".py",\
   "mimetype": "text/x-python",\
   "name": "python",\
   "nbconvert_exporter": "python",\
   "pygments_lexer": "ipython3",\
   "version": "3.8.3"\
  \}\
 \},\
 "nbformat": 4,\
 "nbformat_minor": 4\
\}}